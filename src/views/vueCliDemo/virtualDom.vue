<template>
  <div id="app">
    <Child v-for="(item,i) in array" :key="i" :text="item" @delete="remove(i)"/>
  </div>
</template>
<script>
import Child from '@/components/Child'
export default {
  name: 'home',
  components: {
    Child
  },
  data () {
    return {
      array: [{ id: 1, value: 1 }, { id: 2, value: 2 }, { id: 3, value: 3 }]
    }
  },
  methods: {
    remove (i) {
      this.array.splice(i, 1)
    }

  },
  mounted () {
  }
}
</script>
https://www.zhihu.com/question/61064119
总结：
一.什么是虚拟dom?
Virtual DOM是对DOM的抽象,本质上是JavaScript对象,这个对象就是更加轻量级的对DOM的描述.

二.为什么需要Virtual DOM?

1、JS操作真实DOM的代价！
  在一次操作中，我需要更新10个DOM节点，浏览器收到第一个DOM请求后并不知道还有9次更新操作
  ，因此会马上进行渲染，渲染的过程有可能会造成回流和重绘，并且第一次计算完，紧接着下一个DOM更新请求，这个节点的坐标值就变了，
  相当于前一次计算为无用功。重复10次渲染，得到最后更新的页面。
  计算DOM节点坐标值等都是白白浪费的性能。即使计算机硬件一直在迭代更新，操作DOM的代价仍旧是昂贵的，频繁操作还是会出现页面卡顿，影响用户体验。

  首先,我们都知道在前端性能优化的一个秘诀就是尽可能少地操作DOM,不仅仅是DOM相对较慢,
  更因为频繁变动DOM会造成浏览器的回流或者重绘,这些都是性能的杀手,因此我们需要这一层抽象,
  在patch过程中尽可能地一次性将差异更新到DOM中,这样保证了DOM不会出现性能很差的情况.

2、为什么需要虚拟DOM，它有什么好处?
  Web界面由DOM树(树的意思是数据结构)来构建，当其中一部分发生变化时，其实就是对应某个DOM节点发生了变化，
  虚拟DOM就是为了解决浏览器性能问题而被设计出来的。
  虚拟dom其实就是真实dom树的映射。如前，若一次操作中有10次更新DOM的动作，浏览器不会立马渲染，
  而是现将这10次更新的diff内容保存到本地一个JS对象中，最终将这个JS对象一次性attch到DOM树上，再进行后续操作，避免大量无谓的计算量。
  所以，用JS对象模拟DOM节点的好处是，页面的更新可以先全部反映在JS对象(虚拟DOM)上，操作内存中的JS对象的速度显然要更快，等更新完成后，再将最终的JS对象映射成真实的DOM，交由浏览器去绘制。

三、当数据发生变化时，vue是怎么更新节点的？(虚拟Dom的diff算法)
  我们先根据真实DOM生成一颗 virtual DOM ，当数据有变化时，vue会自动更新虚拟dom，将对同一层次新的Vnode和旧的oldNode比较(diff算法，只比较同一层级的节点)
  然后得到一个diff，然后修改在真实的dom上。当前的Vnode替换到oldNode

四、虚拟dom的diff算法
  vue和react的虚拟DOM的Diff算法大致相同，其核心是基于两个简单的假设：
    1. 两个相同的组件产生类似的DOM结构，不同的组件产生不同的DOM结构。
    2. 同一层级的一组节点，他们可以通过唯一的id进行区分。
  基于以上这两点假设，使得虚拟DOM的Diff算法的复杂度从O(n^3)降到了O(n)。

  当页面的数据发生变化时，Diff算法只会比较同一层级的节点：
    1. 如果节点类型不同，直接干掉前面的节点，再创建并插入新的节点，不会再比较这个节点以后的子节点了。
    2. 如果节点类型相同，则Vue会直接复用旧DOM节点(就地复用)，只要更新节点中的内容(由数据变化带来的内容更新)，从而实现节点的更新。
  当某一层有很多相同的节点时，也就是列表节点时，Diff算法的更新过程默认情况下也是遵循以上原则。

五.vue中的key有什么用？
  当某一层有很多相同的节点时，也就是列表节点时。如果列表数据有变化时，比如从[a,b,c,d,e] 插入了一个f,即[a,b,f,c,d,e]，根据diff算法更新节点的原则，
  a，b节点可以就地复用，原来的c节点与新节点f类型相同，可复用，但是需要更新c节点的内容为f，
  原来的d节点与新的c节点类型也相同，可复用，但是更新d节点的内容为c
  同理，一直比较下去，最后发现e是一个新节点，直接插入。这样很没有效率，并且因为复用，可能会达不到想要的效果。
  如果不加key,那么vue会选择复用节点(Vue的就地更新策略),导致之前节点的状态被保留下来,会产生一系列的bug.

  所以我们需要使用key来给每个节点做一个唯一标识，Diff算法就可以正确的识别此节点，找到正确的位置区插入新的节点。
  是key的作用是为了在diff算法执行时更快的找到对应的节点，提高diff速度
  为了给 Vue 一个提示，以便它能跟踪每个节点的身份，从而重用和重新排序现有元素，你需要为每项提供一个唯一 key 属性：

  官网：
    当 Vue 正在更新使用 v-for 渲染的元素列表时，它默认使用“就地更新”的策略。如果数据项的顺序被改变，Vue 将不会移动 DOM 元素来匹配数据项的顺序
    ，而是就地更新每个元素，并且确保它们在每个索引位置正确渲染。这个类似 Vue 1.x 的 track-by="$index"。
    这个默认的模式是高效的，但是只适用于不依赖子组件状态或临时 DOM 状态 (例如：表单输入值) 的列表渲染输出。

    为了给 Vue 一个提示，以便它能跟踪每个节点的身份，从而重用和重新排序现有元素，你需要为每项提供一个唯一 key 属性：

    <div v-for="item in items" v-bind:key="item.id">
    <!-- 内容 -->
    </div>
    建议尽可能在使用 v-for 时提供 key attribute，除非遍历输出的 DOM 内容非常简单，或者是刻意依赖默认行为以获取性能上的提升。

    因为它是 Vue 识别节点的一个通用机制，key 并不仅与 v-for 特别关联。后面我们将在指南中看到，它还具有其它用途。
https://www.xinran001.com/frontend/275.html

"原地复用"不产生副作用的情况下，不用key效率最快。
"原地复用"产生副作用，需要用key，且用key通过map查找比遍历查找效率更快。
用key的主要作用是不产生副作用，跟不用key去比效率就没意义了，不是一个层面上的事，效率较快是和遍历查找相比而言。
